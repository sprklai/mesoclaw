# Frontend Internationalization (i18n) Design

**Date:** 2026-02-16
**Status:** Approved
**Scope:** Frontend only (backend remains English-only)

## Overview

This design document outlines the implementation of internationalization (i18n) for MesoClaw's React frontend. The goal is to build a flexible i18n infrastructure that starts with English but can easily support any language in the future, including European languages, Asian languages, and RTL languages.

## Requirements

1. **Language Support**: Start with English, architect for future flexibility
2. **Translation Scope**: All user-facing content (UI text, errors, notifications, success messages, help text, placeholders)
3. **Language Switching**: Auto-detect from OS + manual override in Settings
4. **Full Localization**: Translate text AND format dates, numbers, currency, and time according to locale
5. **Backend**: Remains English-only (no Rust changes)

## Technology Decision: react-i18next

**Selected library:** react-i18next (with i18next core)

**Rationale:**
- Industry standard with proven reliability
- Excellent TypeScript support with type-safe translation keys
- Built-in OS language detection via `i18next-browser-languagedetector`
- Namespace support for organizing translations by feature
- Plugin ecosystem for formatting (i18next-icu)
- Lazy loading for optimal performance
- Clean hook-based API that fits React 19 patterns

**Alternatives considered:**
- `typesafe-i18n` - Better compile-time safety but less mature, manual formatting
- `react-intl` - Excellent formatting but component-heavy API, no built-in language detection

**Bundle impact:** ~14kb gzipped (negligible for desktop app)

---

## Architecture

### Integration Overview

```
┌─────────────────────────────────────────────────────────┐
│                    React App (main.tsx)                 │
│                                                         │
│  ┌──────────────────────────────────────────────────┐  │
│  │         i18next Provider Wrapper                  │  │
│  │  - Detects OS language on init                    │  │
│  │  - Loads English translations (default)           │  │
│  │  - Provides translation context to all components │  │
│  └──────────────────────────────────────────────────┘  │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐  │
│  │         Existing App Components                   │  │
│  │  - Use useTranslation() hook                      │  │
│  │  - Access t() function for translations           │  │
│  │  - Access i18n.format() for date/number           │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
              ▼                           ▼
    ┌──────────────────┐      ┌──────────────────────┐
    │  Translation     │      │  Tauri Settings      │
    │  Files (JSON)    │      │  (persist language)  │
    │  src/locales/    │      │  via plugin-store    │
    └──────────────────┘      └──────────────────────┘
```

### Key Integration Points

1. **App initialization** (`main.tsx`): Initialize i18next before React mounts
2. **Settings integration**: Add language selector to Settings → App tab
3. **Language persistence**: Store selected language in both localStorage and Tauri settings
4. **OS detection**: Auto-detect language on first launch via browser API
5. **No backend changes**: Backend stays English-only as requested

### Dependencies

```json
{
  "i18next": "^23.x",
  "react-i18next": "^14.x",
  "i18next-browser-languagedetector": "^7.x",
  "i18next-icu": "^2.x"
}
```

---

## File Structure

### Translation Files Organization

```
src/
├── locales/
│   ├── en/                          # English (default)
│   │   ├── common.json              # Common UI elements
│   │   ├── settings.json            # Settings page
│   │   ├── errors.json              # Error messages
│   │   ├── notifications.json       # Toast/notification messages
│   │   ├── chat.json                # Chat interface
│   │   ├── ai.json                  # AI-related text
│   │   └── validation.json          # Form validation
│   │
│   ├── es/                          # Spanish (future)
│   │   └── ...
│   │
│   └── index.ts                     # Exports
│
├── lib/
│   ├── i18n.ts                      # i18next initialization
│   └── format.ts                    # Formatting utilities
│
└── types/
    └── i18next.d.ts                 # TypeScript type definitions
```

### Namespace Strategy

**Why namespaces?** Keeps translation files manageable, enables lazy loading per feature.

| Namespace | Contains | Example Keys |
|-----------|----------|--------------|
| `common` | Shared UI elements | `actions.save`, `navigation.home` |
| `settings` | Settings page content | `appearance.title`, `theme.label` |
| `errors` | Error messages | `connection.failed`, `validation.required` |
| `notifications` | Toast messages | `workspaceCreated`, `settingsSaved` |
| `chat` | Chat interface | `placeholder`, `emptyState.title` |
| `ai` | AI-specific text | `providers.openai`, `skills.description` |
| `validation` | Form validation | `required`, `minLength` |

### Example Translation Files

**`src/locales/en/common.json`:**
```json
{
  "actions": {
    "save": "Save",
    "cancel": "Cancel",
    "delete": "Delete",
    "edit": "Edit",
    "create": "Create",
    "copy": "Copy",
    "close": "Close"
  },
  "navigation": {
    "home": "Home",
    "settings": "Settings",
    "chat": "Chat"
  },
  "loading": "Loading...",
  "noResults": "No results found"
}
```

**`src/locales/en/settings.json`:**
```json
{
  "title": "Settings",
  "tabs": {
    "app": "App Settings",
    "ai": "AI Settings",
    "advanced": "Advanced"
  },
  "appearance": {
    "title": "Appearance",
    "description": "Customize how the application looks",
    "theme": {
      "label": "Theme",
      "description": "Select your preferred color scheme",
      "light": "Light",
      "dark": "Dark",
      "system": "System"
    },
    "language": {
      "label": "Language",
      "description": "Choose your preferred language"
    }
  }
}
```

---

## Implementation

### i18next Configuration

**`src/lib/i18n.ts`:**

```typescript
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import LanguageDetector from 'i18next-browser-languagedetector';
import ICU from 'i18next-icu';

// Import English namespaces
import commonEn from '@/locales/en/common.json';
import settingsEn from '@/locales/en/settings.json';
import errorsEn from '@/locales/en/errors.json';
import notificationsEn from '@/locales/en/notifications.json';
import chatEn from '@/locales/en/chat.json';
import aiEn from '@/locales/en/ai.json';
import validationEn from '@/locales/en/validation.json';

i18n
  .use(ICU)                       // Date/number formatting
  .use(LanguageDetector)          // OS language detection
  .use(initReactI18next)          // React bindings
  .init({
    resources: {
      en: {
        common: commonEn,
        settings: settingsEn,
        errors: errorsEn,
        notifications: notificationsEn,
        chat: chatEn,
        ai: aiEn,
        validation: validationEn,
      },
    },
    fallbackLng: 'en',
    defaultNS: 'common',
    ns: ['common', 'settings', 'errors', 'notifications', 'chat', 'ai', 'validation'],

    interpolation: {
      escapeValue: false,           // React already escapes
    },

    detection: {
      order: ['localStorage', 'navigator'],
      caches: ['localStorage'],
      lookupLocalStorage: 'i18nextLng',
    },
  });

export default i18n;
```

### App Initialization

**`src/main.tsx`:**

```typescript
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './lib/i18n';  // ← Initialize i18n first

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

### Component Usage Patterns

**Pattern 1: Simple translations**
```typescript
import { useTranslation } from 'react-i18next';

export function HomePage() {
  const { t } = useTranslation('common');

  return (
    <div>
      <h1>{t('navigation.home')}</h1>
      <Button>{t('actions.save')}</Button>
    </div>
  );
}
```

**Pattern 2: Multiple namespaces**
```typescript
export function SettingsPage() {
  const { t } = useTranslation(['settings', 'common']);

  return (
    <div>
      <h1>{t('settings:title')}</h1>
      <Button>{t('common:actions.save')}</Button>
    </div>
  );
}
```

**Pattern 3: Interpolation**
```typescript
const { t } = useTranslation('notifications');
toast.success(t('workspaceCreated', { name: workspaceName }));

// In JSON: "workspaceCreated": "Workspace '{{name}}' created successfully"
```

**Pattern 4: Pluralization**
```typescript
const { t } = useTranslation('common');
<p>{t('itemCount', { count: items.length })}</p>

// In JSON:
// "itemCount_one": "{{count}} item",
// "itemCount_other": "{{count}} items"
```

### TypeScript Type Safety

**`src/types/i18next.d.ts`:**

```typescript
import 'react-i18next';
import type commonEn from '@/locales/en/common.json';
import type settingsEn from '@/locales/en/settings.json';
import type errorsEn from '@/locales/en/errors.json';
import type notificationsEn from '@/locales/en/notifications.json';
import type chatEn from '@/locales/en/chat.json';
import type aiEn from '@/locales/en/ai.json';
import type validationEn from '@/locales/en/validation.json';

declare module 'react-i18next' {
  interface CustomTypeOptions {
    defaultNS: 'common';
    resources: {
      common: typeof commonEn;
      settings: typeof settingsEn;
      errors: typeof errorsEn;
      notifications: typeof notificationsEn;
      chat: typeof chatEn;
      ai: typeof aiEn;
      validation: typeof validationEn;
    };
  }
}
```

This provides **autocomplete** and **type errors** for invalid translation keys!

---

## Language Detection & Switching

### OS Language Detection Flow

**On first app launch:**

1. `i18next-browser-languagedetector` checks:
   - localStorage `i18nextLng` (user's previous choice)
   - `navigator.language` (OS language)
   - Fallback to 'en' if not found

2. If detected language has translations → use it
   Else → fallback to English

3. Store choice in localStorage for next launch

**How it detects:**
```typescript
navigator.language      // e.g., 'en-US', 'es-ES', 'ja-JP'
navigator.languages     // Array of user's language preferences

// i18next normalizes to base language code
'en-US' → 'en'
'es-419' → 'es'
'zh-CN' → 'zh'
```

### Settings Integration

Add language selector to **`src/components/settings/AppSettingsTab.tsx`:**

```typescript
import { useTranslation } from 'react-i18next';

const LANGUAGE_OPTIONS = [
  { value: 'en', label: 'English' },
  // Future: { value: 'es', label: 'Español' },
] as const;

export function AppSettingsTab() {
  const { t, i18n } = useTranslation(['settings', 'common']);

  const handleLanguageChange = async (newLanguage: string) => {
    await i18n.changeLanguage(newLanguage);

    // Persist to Tauri settings (backup)
    await invoke('update_setting_command', {
      key: 'language',
      value: newLanguage,
    });
  };

  return (
    <SettingsSection title={t('settings:appearance.title')}>
      <SettingRow
        label={t('settings:appearance.language.label')}
        description={t('settings:appearance.language.description')}
      >
        <Select
          value={i18n.language}
          onValueChange={handleLanguageChange}
          options={LANGUAGE_OPTIONS}
        />
      </SettingRow>
    </SettingsSection>
  );
}
```

### Persistence Strategy

**Two-layer persistence:**

1. **Primary: localStorage** (via i18next-browser-languagedetector)
   - Fast, automatic
   - Works offline

2. **Secondary: Tauri settings** (via plugin-store)
   - Backend persistence
   - Survives localStorage clear

**Recovery flow:**
```typescript
const storedLanguage = localStorage.getItem('i18nextLng')
  || await invoke('get_setting_command', { key: 'language' })
  || 'en';

i18n.changeLanguage(storedLanguage);
```

---

## Formatting

### Strategy

Use native **`Intl` API** for all formatting - zero extra dependencies, perfect locale support.

### Formatting Utilities

**`src/lib/format.ts`:**

```typescript
import { useTranslation } from 'react-i18next';

export function useFormatters() {
  const { i18n } = useTranslation();
  const locale = i18n.language;

  return {
    // Date formatting
    formatDate: (date: Date | string, options?: Intl.DateTimeFormatOptions) => {
      const dateObj = typeof date === 'string' ? new Date(date) : date;
      return new Intl.DateTimeFormat(locale, {
        dateStyle: 'medium',
        ...options,
      }).format(dateObj);
    },

    formatDateShort: (date: Date | string) => {
      const dateObj = typeof date === 'string' ? new Date(date) : date;
      return new Intl.DateTimeFormat(locale, { dateStyle: 'short' }).format(dateObj);
    },

    formatDateLong: (date: Date | string) => {
      const dateObj = typeof date === 'string' ? new Date(date) : date;
      return new Intl.DateTimeFormat(locale, { dateStyle: 'long' }).format(dateObj);
    },

    formatTime: (date: Date | string) => {
      const dateObj = typeof date === 'string' ? new Date(date) : date;
      return new Intl.DateTimeFormat(locale, { timeStyle: 'short' }).format(dateObj);
    },

    formatDateTime: (date: Date | string) => {
      const dateObj = typeof date === 'string' ? new Date(date) : date;
      return new Intl.DateTimeFormat(locale, {
        dateStyle: 'medium',
        timeStyle: 'short',
      }).format(dateObj);
    },

    // Relative time: "2 hours ago"
    formatRelativeTime: (date: Date | string) => {
      const dateObj = typeof date === 'string' ? new Date(date) : date;
      const now = new Date();
      const diffMs = now.getTime() - dateObj.getTime();
      const diffSec = Math.floor(diffMs / 1000);
      const diffMin = Math.floor(diffSec / 60);
      const diffHour = Math.floor(diffMin / 60);
      const diffDay = Math.floor(diffHour / 24);

      const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });

      if (diffDay > 0) return rtf.format(-diffDay, 'day');
      if (diffHour > 0) return rtf.format(-diffHour, 'hour');
      if (diffMin > 0) return rtf.format(-diffMin, 'minute');
      return rtf.format(-diffSec, 'second');
    },

    // Number formatting
    formatNumber: (num: number, options?: Intl.NumberFormatOptions) => {
      return new Intl.NumberFormat(locale, options).format(num);
    },

    // Currency formatting
    formatCurrency: (amount: number, currency = 'USD', options?: Intl.NumberFormatOptions) => {
      return new Intl.NumberFormat(locale, {
        style: 'currency',
        currency,
        ...options,
      }).format(amount);
    },

    // Percent formatting
    formatPercent: (value: number, options?: Intl.NumberFormatOptions) => {
      return new Intl.NumberFormat(locale, {
        style: 'percent',
        ...options,
      }).format(value);
    },

    // File size formatting
    formatFileSize: (bytes: number) => {
      const units = ['B', 'KB', 'MB', 'GB', 'TB'];
      let size = bytes;
      let unitIndex = 0;

      while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex++;
      }

      return `${new Intl.NumberFormat(locale, {
        maximumFractionDigits: 2,
      }).format(size)} ${units[unitIndex]}`;
    },
  };
}
```

### Usage Examples

```typescript
import { useFormatters } from '@/lib/format';

export function WorkspaceCard({ workspace }) {
  const { formatDate, formatRelativeTime } = useFormatters();

  return (
    <Card>
      <p>Created: {formatDate(workspace.createdAt)}</p>
      <p>Last used: {formatRelativeTime(workspace.lastAccessedAt)}</p>
    </Card>
  );
}
```

### Locale-Specific Output

**English (en-US):**
- Date: `2/16/2026`
- Time: `2:30 PM`
- Number: `1,234.56`
- Currency: `$1,234.56`
- Relative: `2 hours ago`

**Spanish (es-ES):**
- Date: `16/2/2026`
- Time: `14:30`
- Number: `1.234,56`
- Currency: `1.234,56 €`
- Relative: `hace 2 horas`

**Japanese (ja-JP):**
- Date: `2026/2/16`
- Time: `14:30`
- Number: `1,234.56`
- Currency: `¥1,235`
- Relative: `2 時間前`

---

## Migration Strategy

### Goal

Replace all hardcoded English strings with translation keys without breaking functionality.

### Step-by-Step Process

**Phase 1: Create Translation Files (Day 1)**

1. Scan codebase for all user-facing text
2. Extract strings into namespace-organized JSON files
3. Create translation keys following consistent naming pattern

**Naming convention:**
```typescript
// Good keys (descriptive, hierarchical)
"settings.appearance.title"
"errors.connection.failed"
"notifications.workspace.created"

// Bad keys (vague, flat)
"title", "error1", "msg"
```

**Phase 2: Install Dependencies (Day 1)**

```bash
bun add i18next react-i18next i18next-browser-languagedetector i18next-icu
```

**Phase 3: Setup Infrastructure (Day 1)**

1. Create `src/lib/i18n.ts`
2. Create `src/locales/en/` directory structure
3. Add type definitions in `src/types/i18next.d.ts`
4. Import i18n in `main.tsx`

**Phase 4: Migrate Components (Day 2-3)**

Migrate systematically by feature area:

1. Settings page (isolated test case)
2. Home page (user entry point)
3. Common components (buttons, dialogs)
4. Chat interface
5. Error messages
6. Notifications

### Component Migration Pattern

**Before:**
```tsx
export function AppSettingsTab() {
  return (
    <SettingsSection title="Appearance" description="Customize how the application looks">
      <SettingRow label="Theme" description="Select your preferred color scheme">
        <Select options={THEME_OPTIONS} />
      </SettingRow>
    </SettingsSection>
  );
}
```

**After:**
```tsx
import { useTranslation } from 'react-i18next';

export function AppSettingsTab() {
  const { t } = useTranslation('settings');

  return (
    <SettingsSection
      title={t('appearance.title')}
      description={t('appearance.description')}
    >
      <SettingRow
        label={t('appearance.theme.label')}
        description={t('appearance.theme.description')}
      >
        <Select options={THEME_OPTIONS} />
      </SettingRow>
    </SettingsSection>
  );
}
```

### Special Cases

**1. Dynamic content:**
```tsx
// Before
toast.success(`Workspace '${name}' created successfully`);

// After
toast.success(t('notifications:workspaceCreated', { name }));

// JSON: "workspaceCreated": "Workspace '{{name}}' created successfully"
```

**2. Pluralization:**
```tsx
// Before
const text = count === 1 ? '1 table' : `${count} tables`;

// After
const text = t('common:tableCount', { count });

// JSON: "tableCount_one": "{{count}} table", "tableCount_other": "{{count}} tables"
```

**3. Rich text:**
```tsx
import { Trans } from 'react-i18next';

<Trans i18nKey="common:helpText">
  Visit our <a href="/docs">documentation</a> for more info
</Trans>

// JSON: "helpText": "Visit our <1>documentation</1> for more info"
```

**4. Constants/dropdowns:**
```tsx
function useThemeOptions() {
  const { t } = useTranslation('settings');
  return [
    { value: 'light', label: t('theme.light') },
    { value: 'dark', label: t('theme.dark') },
    { value: 'system', label: t('theme.system') },
  ];
}
```

### Automated Extraction

**Optional: Use i18next-parser:**

```bash
bun add -d i18next-parser

# i18next-parser.config.js
module.exports = {
  locales: ['en'],
  output: 'src/locales/$LOCALE/$NAMESPACE.json',
  input: ['src/**/*.{ts,tsx}'],
  defaultNamespace: 'common',
};

bunx i18next-parser
```

### Rollout Plan

**Week 1:**
- Setup infrastructure
- Migrate Settings page
- Create formatting utilities
- Add language selector

**Week 2:**
- Migrate Home page
- Migrate common UI components
- Migrate error messages

**Week 3:**
- Migrate Chat interface
- Migrate notifications
- Final testing

---

## Testing Strategy

### 1. Unit Tests - Translation Files

**`src/__tests__/i18n/translations.test.ts`:**

```typescript
import { describe, it, expect } from 'vitest';
import commonEn from '@/locales/en/common.json';
import settingsEn from '@/locales/en/settings.json';

describe('Translation Files', () => {
  it('should have valid JSON structure', () => {
    expect(commonEn).toBeDefined();
    expect(settingsEn).toBeDefined();
  });

  it('should not have empty strings', () => {
    const checkEmpty = (obj: any): string[] => {
      const empty: string[] = [];
      for (const [key, value] of Object.entries(obj)) {
        if (typeof value === 'string' && !value.trim()) {
          empty.push(key);
        } else if (typeof value === 'object') {
          empty.push(...checkEmpty(value));
        }
      }
      return empty;
    };

    expect(checkEmpty(commonEn)).toHaveLength(0);
  });
});
```

### 2. Component Tests

**Mock i18n in tests:**

```typescript
// src/__tests__/setup.ts
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
    i18n: { language: 'en', changeLanguage: vi.fn() },
  }),
}));
```

### 3. Integration Tests

**Test language switching:**

```typescript
describe('Language Switching', () => {
  it('should change language and persist', async () => {
    await i18n.changeLanguage('es');
    expect(i18n.language).toBe('es');
    expect(localStorage.getItem('i18nextLng')).toBe('es');
  });
});
```

### 4. Formatting Tests

```typescript
describe('useFormatters', () => {
  it('should format dates according to locale', () => {
    i18n.changeLanguage('en-US');
    const { result } = renderHook(() => useFormatters());
    const formatted = result.current.formatDate(new Date('2026-02-16'));
    expect(formatted).toMatch(/Feb.*16.*2026/);
  });
});
```

### 5. Manual Testing Checklist

- [ ] Language selector works
- [ ] Language persists after restart
- [ ] All text translates (no missing keys)
- [ ] Dates/numbers format correctly
- [ ] Pluralization works
- [ ] Error messages display correctly
- [ ] OS detection works on first launch

### 6. CI/CD Integration

```yaml
# .github/workflows/test.yml
- name: Run i18n tests
  run: bun test src/__tests__/i18n

- name: Check for hardcoded strings
  run: |
    ! grep -r "\"[A-Z][a-z]* [a-z]*\"" src/components --include="*.tsx"
```

---

## Success Criteria

1. ✅ All user-facing text translatable (no hardcoded strings)
2. ✅ Language auto-detected from OS on first launch
3. ✅ Language selector in Settings works
4. ✅ Language choice persists across restarts
5. ✅ Dates, numbers, currency formatted per locale
6. ✅ Type-safe translation keys (autocomplete + errors)
7. ✅ Zero runtime errors when switching languages
8. ✅ All tests pass
9. ✅ Bundle size impact < 20kb
10. ✅ No performance degradation

## Future Enhancements

1. Add Spanish, French, German translations
2. Add Asian language support (Japanese, Chinese, Korean)
3. Add RTL language support (Arabic, Hebrew)
4. Translation management UI (in-app translation editor)
5. Automatic translation via AI (OpenAI API)
6. Context-aware translations (different translations for same key in different contexts)
7. Translation memory (reuse translations across versions)

---

## References

- [react-i18next Documentation](https://react.i18next.com/)
- [i18next Documentation](https://www.i18next.com/)
- [MDN Intl API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)
- [CLDR Locale Data](https://cldr.unicode.org/)
