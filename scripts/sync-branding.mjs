#!/usr/bin/env node

import { promises as fs } from 'node:fs';
import path from 'node:path';

const root = process.cwd();
const cfgPath = path.join(root, 'branding.config.json');

async function readJson(file) {
  return JSON.parse(await fs.readFile(file, 'utf8'));
}

function ensure(condition, message) {
  if (!condition) throw new Error(message);
}

function replaceTitle(html, value) {
  return html.replace(/<title>[\s\S]*?<\/title>/i, `<title>${value}</title>`);
}

function replaceInSection(toml, section, key, value) {
  const lines = toml.split('\n');
  let inSection = false;
  let sectionFound = false;
  let keyUpdated = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const sectionMatch = line.match(/^\s*\[(.+)\]\s*$/);
    if (sectionMatch) {
      inSection = sectionMatch[1] === section;
      if (inSection) sectionFound = true;
      continue;
    }

    if (!inSection) continue;

    if (/^\s*[A-Za-z0-9_.-]+\s*=/.test(line)) {
      const keyMatch = line.match(/^\s*([A-Za-z0-9_.-]+)\s*=\s*/);
      if (keyMatch && keyMatch[1] === key) {
        lines[i] = `${key} = "${value}"`;
        keyUpdated = true;
        break;
      }
    }
  }

  if (!sectionFound) {
    throw new Error(`Missing [${section}] section in Cargo.toml`);
  }
  if (!keyUpdated) {
    throw new Error(`Failed to update key '${key}' in [${section}] section`);
  }

  return lines.join('\n');
}

function readValueInSection(toml, section, key) {
  const lines = toml.split('\n');
  let inSection = false;
  let sectionFound = false;

  for (const line of lines) {
    const sectionMatch = line.match(/^\s*\[(.+)\]\s*$/);
    if (sectionMatch) {
      inSection = sectionMatch[1] === section;
      if (inSection) sectionFound = true;
      continue;
    }

    if (!inSection) continue;

    const keyMatch = line.match(/^\s*([A-Za-z0-9_.-]+)\s*=\s*"([^"]*)"\s*$/);
    if (keyMatch && keyMatch[1] === key) {
      return keyMatch[2];
    }
  }

  if (!sectionFound) {
    throw new Error(`Missing [${section}] section in Cargo.toml`);
  }
  throw new Error(`Missing key '${key}' in [${section}] section`);
}

function escapeRegExp(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function rewriteCratePathPrefix(content, oldCrateName, newCrateName) {
  if (oldCrateName === newCrateName) return content;
  const pattern = new RegExp(`\\b${escapeRegExp(oldCrateName)}::`, 'g');
  return content.replace(pattern, `${newCrateName}::`);
}

async function listFilesRecursive(dir) {
  const result = [];
  let entries = [];

  try {
    entries = await fs.readdir(dir, { withFileTypes: true });
  } catch {
    return result;
  }

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      result.push(...(await listFilesRecursive(fullPath)));
    } else if (entry.isFile()) {
      result.push(fullPath);
    }
  }

  return result;
}

function buildIdentity(cfg) {
  const bundleIdentifier = `${cfg.reverseDomain}.${cfg.slug}`;
  const openRouterHttpReferer =
    cfg.openRouterHttpReferer || `https://${cfg.slug}.app`;
  return {
    productName: cfg.productName,
    slug: cfg.slug,
    reverseDomain: cfg.reverseDomain,
    bundleIdentifier,
    iconAssetPath: cfg.iconAssetPath || `/${cfg.slug}-icon.png`,
    keychainService: cfg.keychainService || bundleIdentifier,
    credentialsService:
      cfg.credentialsService || `${bundleIdentifier}.credentials`,
    strongholdClientName:
      cfg.strongholdClientName || `${cfg.slug}-secrets`,
    strongholdVaultPassword:
      cfg.strongholdVaultPassword || `${cfg.slug}-secure-vault`,
    openRouterHttpReferer,
    openRouterTitle: cfg.openRouterTitle || cfg.productName,
    trayTooltip: cfg.trayTooltip || cfg.productName,
    skillsConfigDirName: cfg.skillsConfigDirName || cfg.slug
  };
}

function buildIdentityTs(identity) {
  return `// Auto-generated by scripts/sync-branding.mjs. Do not edit manually.\n\nexport const APP_IDENTITY = ${JSON.stringify(identity, null, 2)} as const;\n`;
}

function buildIdentityRs(identity) {
  return `// Auto-generated by scripts/sync-branding.mjs. Do not edit manually.

pub const PRODUCT_NAME: &str = ${JSON.stringify(identity.productName)};
pub const SLUG: &str = ${JSON.stringify(identity.slug)};
pub const REVERSE_DOMAIN: &str = ${JSON.stringify(identity.reverseDomain)};
pub const BUNDLE_IDENTIFIER: &str = ${JSON.stringify(identity.bundleIdentifier)};
pub const ICON_ASSET_PATH: &str = ${JSON.stringify(identity.iconAssetPath)};
pub const KEYCHAIN_SERVICE: &str = ${JSON.stringify(identity.keychainService)};
pub const CREDENTIALS_SERVICE: &str = ${JSON.stringify(identity.credentialsService)};
pub const STRONGHOLD_CLIENT_NAME: &str = ${JSON.stringify(identity.strongholdClientName)};
pub const STRONGHOLD_VAULT_PASSWORD: &str = ${JSON.stringify(identity.strongholdVaultPassword)};
pub const OPENROUTER_HTTP_REFERER: &str = ${JSON.stringify(identity.openRouterHttpReferer)};
pub const OPENROUTER_TITLE: &str = ${JSON.stringify(identity.openRouterTitle)};
pub const TRAY_TOOLTIP: &str = ${JSON.stringify(identity.trayTooltip)};
pub const SKILLS_CONFIG_DIR_NAME: &str = ${JSON.stringify(identity.skillsConfigDirName)};
`;
}

async function main() {
  const cfg = await readJson(cfgPath);

  ensure(cfg.productName, 'branding.config.json: productName is required');
  ensure(cfg.slug, 'branding.config.json: slug is required');
  ensure(cfg.reverseDomain, 'branding.config.json: reverseDomain is required');

  const identity = buildIdentity(cfg);

  const packageJsonPath = path.join(root, 'package.json');
  const packageJson = await readJson(packageJsonPath);
  packageJson.name = cfg.npmPackageName || cfg.slug;
  await fs.writeFile(packageJsonPath, `${JSON.stringify(packageJson, null, 2)}\n`);

  const tauriPackageJsonPath = path.join(root, 'src-tauri', 'package.json');
  const tauriPackageJson = await readJson(tauriPackageJsonPath);
  tauriPackageJson.name = cfg.tauriNpmPackageName || `${cfg.slug}-tauri`;
  await fs.writeFile(
    tauriPackageJsonPath,
    `${JSON.stringify(tauriPackageJson, null, 2)}\n`
  );

  const tauriConfPath = path.join(root, 'src-tauri', 'tauri.conf.json');
  const tauriConf = await readJson(tauriConfPath);
  tauriConf.productName = cfg.productName;
  tauriConf.identifier = identity.bundleIdentifier;

  if (tauriConf.app?.windows?.[0]) {
    tauriConf.app.windows[0].title = cfg.mainWindowTitle || cfg.productName;
  }

  await fs.writeFile(tauriConfPath, `${JSON.stringify(tauriConf, null, 2)}\n`);

  const cargoPath = path.join(root, 'src-tauri', 'Cargo.toml');
  let cargoToml = await fs.readFile(cargoPath, 'utf8');
  const previousCargoLibName = readValueInSection(cargoToml, 'lib', 'name');
  const nextCargoLibName = cfg.cargoLibName || `${cfg.slug.replace(/-/g, '_')}_lib`;
  cargoToml = replaceInSection(
    cargoToml,
    'package',
    'name',
    cfg.cargoPackageName || cfg.slug
  );
  cargoToml = replaceInSection(cargoToml, 'lib', 'name', nextCargoLibName);
  await fs.writeFile(cargoPath, cargoToml);

  if (previousCargoLibName !== nextCargoLibName) {
    const sourceDir = path.join(root, 'src-tauri', 'src');
    const testsDir = path.join(root, 'src-tauri', 'tests');
    const rustFiles = [
      ...(await listFilesRecursive(sourceDir)),
      ...(await listFilesRecursive(testsDir))
    ].filter((file) => file.endsWith('.rs'));

    for (const rustFile of rustFiles) {
      const rustContent = await fs.readFile(rustFile, 'utf8');
      const nextRustContent = rewriteCratePathPrefix(
        rustContent,
        previousCargoLibName,
        nextCargoLibName
      );
      if (nextRustContent !== rustContent) {
        await fs.writeFile(rustFile, nextRustContent);
      }
    }
  }

  const indexPath = path.join(root, 'index.html');
  const indexHtml = await fs.readFile(indexPath, 'utf8');
  await fs.writeFile(indexPath, replaceTitle(indexHtml, cfg.htmlTitle || cfg.productName));

  const splashPath = path.join(root, 'splash.html');
  let splashHtml = await fs.readFile(splashPath, 'utf8');
  splashHtml = replaceTitle(splashHtml, cfg.splashTitle || cfg.productName);
  splashHtml = splashHtml.replace(
    /<h1[^>]*>[\s\S]*?<\/h1>/i,
    `<h1 class="text-2xl font-bold text-foreground">${cfg.splashTitle || cfg.productName}</h1>`
  );
  splashHtml = splashHtml.replace(
    /<p[^>]*>[\s\S]*?<\/p>/i,
    `<p class="mt-2 text-muted-foreground">\n        ${cfg.splashSubtitle || `${cfg.productName} in minutes!`}\n      </p>`
  );
  await fs.writeFile(splashPath, splashHtml);

  const checkVaultPath = path.join(root, 'check-vault.sh');
  let checkVault = await fs.readFile(checkVaultPath, 'utf8');
  checkVault = checkVault.replace(
    /^LINUX_VAULT_DIR=.*$/m,
    `LINUX_VAULT_DIR=\"$HOME/.local/share/${identity.credentialsService}\"`
  );
  await fs.writeFile(checkVaultPath, checkVault);

  const identityTsPath = path.join(root, 'src', 'config', 'app-identity.ts');
  await fs.mkdir(path.dirname(identityTsPath), { recursive: true });
  await fs.writeFile(identityTsPath, buildIdentityTs(identity));

  const identityRsPath = path.join(root, 'src-tauri', 'src', 'config', 'app_identity.rs');
  await fs.mkdir(path.dirname(identityRsPath), { recursive: true });
  await fs.writeFile(identityRsPath, buildIdentityRs(identity));

  console.log('Branding sync complete.');
}

main().catch((err) => {
  console.error(err.message);
  process.exit(1);
});
